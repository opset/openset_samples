# Sample 'batch' query
#
# This will generate a tree of various database dimensions
# and calculated values comparing two segments.
#
# sections named '@segment' will be generated first. If segments
# have already been created with a standalone 'segment' query you
# may use be used instead or in combination with ones declared here.
#
# The '@use' section specifies which segments you want to compare.
# If none are provided the everyone segment ('*') will be used.
# The segments can be ones defined with an '@segment' section or
# you may use segments you have previously generated with a 'segment' query.
#
# You can have as many '@column' sections as you like. Parameters
# like 'bucket=' can be used in 'column' queries. They are passed as
# key/value pairs on the the '@column' line.
#
# You can have as many '@histogram' sections as you like. Unlike
# column queries which count people in an index, 'histogram' queries
# calculate against 'events' which means you can incorporate
# conditional filters such as date, etc. Like columns you can
# pass parameters.
#
# Additionally you can enumerate a column using '@histogram'. If for
# example you wanted to calculate total value by shipper and compare
# that against another segment, you can the `each=` paramter. The
# value being the name of a column. The script will be replicated
# and an for each value in the column with the {{each}} placeholder
# being filled with a value.
#
@segment products_home ttl=300s use_cached refresh=300s:
    # match one of these
    match where product_group in ['basement', 'garage', 'kitchen', 'bedroom', 'bathroom']:
        tally

@segment products_outdoor ttl=300s use_cached refresh=300s:
    # match one of these
    match where product_group in ['outdoor', 'angling']:
        tally

# specify which segments we want to use for our column and
# historgram queries.
@use products_home products_outdoor

# count the values in the product_name column by poeple
@column product_name

# count the values in the product_group column by people
@column product_group

# count the values in the product_price column by people,
# bucket values into $50 groups
@column product_price bucket=50

# bucket customer value (by SUM of their purchase totals)
# and bucket into $100 groups
@histogram customer_value bucket=100

    return SUM total where total != None # inline aggregation

# returns a list of times since last visit (by days) and the
# number of people for each item in the list.
@histogram days_since
    return int(to_days(now - last_event))

# this will automatically make a tree:
#     '/total_by_shiper/shipper/values'
# it does so by enumerating the values in the shipper column using
# the special 'foreach=' parameter. The query code (below) must use
# the special variable named 'each_value' to allow the script to
# evaluate the for/each correctly. Note that this is counting
# values per user. The return value becomes a branch in the
# result, the person is counted as 1.
@histogram total_by_shipper foreach=shipper bucket=25
   return SUM total where shipper=each_value # inline aggregation
